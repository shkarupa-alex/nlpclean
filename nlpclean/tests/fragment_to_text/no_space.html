<div>Введение в PHP 5.3 замыканий — одно из главных его новшеств и хотя после релиза прошло уже несколько лет, до сих пор не сложилось стандартной практики использования этой возможности языка. В этой статье я попробовал собрать все наиболее интересные возможности по применению замыканий в PHP.<br> <a name="habracut"></a><br>Для начала рассмотрим, что же это такое — замыкание и в чем его особенности в PHP.<br><br><pre><code class="php">$g = 'test';

$c = function($a, $b) use($g){
    echo $a . $b .  $g;
};

$g = 'test2';

var_dump($c);

/*
object(Closure)#1 (2)
{
     ["static"]=> array(1) { ["g"]=> string(4) "test" }
     ["parameter"]=> array(2) {
          ["$a"] => string(10) ""
          ["$b"]=> string(10) ""
      }
}
*/
</code></pre><br>Как видим, замыкание как и лямбда-функция представляют собой объект класса Closure, коорый хранит переданные параметры. Для того, чтобы вызывать объект как функцию, в PHP5.3 ввели магический метод __invoke.<br><br><pre><code class="php">function getClosure()
{
    $g = 'test';

    $c = function($a, $b) use($g){
        echo $a . $b . $g;
    };

    $g = 'test2';

    return $c;
}

$closure = getClosure();
$closure(1, 3); //13test

getClosure()->__invoke(1, 3); //13test

</code></pre><br>Используя конструкцию use мы наследуем переменную из родительской области видимости в локальную область видимости ламбда-функции.<br>Ситаксис прост и понятен. Не совсем понятно применение такого функционала в разработке web-приложений. Я просмотрел код нескольких совеременных фреймворков, использующих новые возможности языка и попытался собрать вместе их различные применения.<br><br><h4>Функции обратного вызова</h4><br>Самое очевидное применение анонимных функций — использование их в качестве функций обратного вызова (callbacks). В PHP имеется множество стандартных функций, принимающих на вход тип callback или его синоним callable введенный в PHP 5.4. Самые популярные из них array_filter, array_map, array_reduce. Функция array_map служит для итеративной обработки элементов массива. Callback-функция применяется к каждому элементу массива и в качестве результата выдается обработанный массив. У меня сразу возникло желание сравнить производительность обычной обработки массива в цикле с применением встроенной функции. Давайте поэкспериментируем.<br><br><pre><code class="php">
$x = range(1, 100000);
$t = microtime(1);

$x2 = array_map(function($v){
    return $v + 1;
}, $x);
//Time: 0.4395
//Memory: 22179776
//---------------------------------------

$x2 = array();
foreach($x as $v){
    $x2[] = $v + 1;
}
//Time: 0.0764
//Memory: 22174788
//---------------------------------------

function tr($v){
    return $v + 1;
}
$x2 = array();
foreach($x as $v){
    $x2[] = tr($v);
}
//Time: 0.4451
//Memory: 22180604
</code></pre><br>Как видно, накладные расходы на большое количество вызовов функций дают ощутимый спад в производительности, чего и следовало ожидать. Хотя тест синтетический, задача обработки больших массивов возникает часто, и в данном случае применение функций обработки данных может стать тем местом, которе будет существенно тормозить ваше приложение. Будьте осторожны. Тем не менее в современных приложениях такой подход используется очень часто. Он позволяет делать код более лаконичным, особенно, если обработчик объявляется где-то в другом месте, а не при вызове.<br><br>По сути в данном контексте применение анонимных функций ничем не отличается от старого способа передачи строкового имени функции или callback-массива за исключением одной особенности — теперь мы можем использовать замыкания, то есть сохранять переменные из области видимости при создании функции. Рассмотрим пример обработки массива данных перед добавлением их в базу данных.<br><br><pre><code class="php">//объявляем функцию квотирования.
$quoter = function($v) use($pdo){
	return $pdo->quote($v);//использовать эту функцию не рекомендуется, тем не менее :-)
}
$service->register(‘quoter’, $quoter);
…
//где-то в другом месте
//теперь у нас нет доступа к PDO
$data = array(...);//массив строк
$data = array_map($this->service->getQuoter(), $data);
//массив содержит обработанные данные.
</code></pre><br>Очень удобно применять анонимные функции и для фильтрации<br><br><pre><code class="php">$x = array_filter($data, function($v){ return $v > 0; });
//vs
$x = array();
foreach($data as $v)
{
	if($v > 0){$x[] = $v}
}
</code></pre><br><h4>События.</h4><br>Замыкания идеально подходят в качестве обработчиков событий. Например<br><br><pre><code class="php">//где-то при конфигурации приложения.
$this->events->on(User::EVENT_REGISTER, function($user){
	//обновить счетчик логинов для пользователя и т.д.
});

$this->events->on(User::EVENT_REGISTER’, function($user){
	//выслать email для подтверждения.
});

//в обработчике формы регистрации
$this->events->trigger(User::EVENT_REGISTER, $user);
</code></pre><br>Вынос логики в обработчики событий с одной стороны делает код более чистым, с другой стороны — усложняет поиск ошибок — поведение системы иногда становится неожиданным для человека, который не знает, какие обработчики навешаны в данный момент. <br><br><h4>Валидация</h4><br>Замыкания по сути сохраняют некоторую логику в переменной, которая может быть выполнена или не выполнена в по ходу работы скрипта. Это то, что нужно для реализации валидаторов:<br><br><pre><code class="php">$notEmpty = function($v){ return strlen($v) > 0 ? true : “Значение не может быть пустым”; };
$greaterZero = function($v){ return $v > 0 ? true : “Значение должно быть больше нуля”; };

function getRangeValidator($min, $max){
	return function($v) use ($min, $max){
		return ($v >= $min && $v <= $max)
                         ? true
                         : “Значение не попадает в промежуток”;
	};
}
</code></pre><br>В последнем случае мы применяем функцию высшего порядка, которая возвращает другую функцию — валидатор с предустановленными границами значений. Применять валидаторы можно, например, так.<br><br><pre><code class="php">class UserForm extends BaseForm{

    public function __constructor()
    {
        $this->addValidator(‘email’, Validators::$notEmpty);
        $this->addValidator(‘age’, Validators::getRangeValidator(18, 55));
        $this->addValidator(‘custom’, function($v){
		//some logic
        });
    }

    /**
    * Находится в базовом классе.
    */
    public function isValid()
    {
        …
        $validationResult = $validator($value);
        if($validationResult !== true){
            $this->addValidationError($field, $validationResult);
        }
        …
    }
}
</code></pre><br>Использование в формах классический пример. Также валидация может использоваться в сеттерах и геттерах обычных классов, моделях и т.д. Хорошим тоном, правда, считается декларативная валидация, когда правила описаны не в форме функций, а в форме правил при конфигурации, тем не менее, иногда такой подход очень кстати.<br><br><h4>Выражения</h4><br>В Symfony встречается очень интересное применение замыканий. Класс <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Config/Definition/Builder/ExprBuilder.php">ExprBuilder</a> опеделяет сущность, которая позволяет строить выражения вида<br><br><pre><code class="php">...
->beforeNormalization()
    ->ifTrue(function($v) { return is_array($v) && is_int(key($v)); })
    ->then(function($v) { return array_map(function($v) { return array('name' => $v); }, $v); })
 ->end()
...
</code></pre><br>В Symfony как я понял это внутренний класс, который используется для создания обработки вложенных конфигурационных массивов (поправьте меня, если не прав). Интересна идея реализации выражений в виде цепочек. В принципе вполне можно реализовать класс, который бы описывал выражения в таком виде:<br><br><pre><code class="php">$expr = new Expression();

$expr
->if(function(){ return $this->v == 4;})
->then(function(){$this->v = 42;})
->else(function(){})
	->elseif(function(){})
->end()
->while(function(){$this->v >=42})
	->do(function(){
		$this->v --;
})
->end()
->apply(function(){/*Some code*/});

$expr->v = 4;
$expr->exec();
echo $expr->v;
</code></pre><br>Применение, конечно, экспериментально. По сути — это запись некоторого алгоритма. Реализация такого функционала достаточно сложна — выражение в идеальном случае должно хранить дерево операций. Инетересна концепция, может быть где-то такая конструкция будет полезна.<br><br><h4>Роутинг</h4><br>Во многих мини-фреймворках роутинг сейчас работает на анонимных функциях.<br><br><pre><code class="php">App::router(‘GET /users’, function() use($app){
    $app->response->write(‘Hello, World!’);
});
</code></pre><br>Достаточно удобно и лаконично.<br><br><h4>Кеширование</h4><br>На хабре это уже обсуждалось, тем не менее.<br><br><pre><code class="php">$someHtml = $this->cashe->get(‘users.list’, function() use($app){
	$users = $app->db->table(‘users)->all();
	return $app->template->render(‘users.list’, $isers);
}, 1000);
</code></pre><br>Здесь метод get проверяет валидность кеша по ключу ‘users.list’ и если он не валиден, то обращается к функции за данными. Третий параметр определяет длительность хранения данных.<br><br><h4>Инициализация по требованию</h4><br>Допустим, у нас есть сервис Mailer, который мы вызываем в некоторых методах. Перед использованием он должен быть сконфигурирован. Чтобы не инициализировать его каждый раз, будем использовать ленивое создание объекта.<br><br><pre><code class="php">//Где-то в конфигурационном файле.
$service->register(‘Mailer’, function(){
	return new Mailer(‘user’, ‘password’, ‘url’);
});

//Где-то в контроллере
$this->service(‘Mailer’)->mail(...);
</code></pre><br>Инициализация объекта произойдет только перед самым первым использованием.<br><br><h4>Изменение поведения объектов</h4><br>Иногда бывает полезно переопределить поведение объектов в процессе выполнения скрипта — добавить метод, переопределить старый, и т.д. Замыкание поможет нам и здесь. В PHP5.3 для этого нужно было использовать различные обходные пути.<br><br><pre><code class="php">class Base{

    public function publicMethod(){echo 'public';}
    private function privateMethod(){echo 'private';}
    //будем перехватывать обращение к замыканию и вызывать его.
    public function __call($name, $arguments) {
        if($this->$name instanceof Closure){
            return call_user_func_array($this->$name, array_merge(array($this), $arguments));
        }
    }
}

$b = new Base;

//создаем новый метод
$b->method = function($self){
    echo 'I am a new dynamic method';
   $self->publicMethod(); //есть доступ только к публичным свойствам и методам
};

$b->method->__invoke($b); //вызов через магический метод

$b->method(); //вызов через перехват обращения к методу

//call_user_func($b->{'method'}, $b); //так не работает
</code></pre><br><br>В принципе можно и переопределять старый метод, однако только в случае если он был определен подобным путем. Не совсем удобно. Поэтому в PHP 5.4 появилось возможность связать замыкание с объектом.<br><br><pre><code class="php">$closure = function(){
	return $this->privateMethod();
}

$closure->bindTo($b,  $b); //второй параметр определяет область видимости
$closure();
</code></pre><br>Конечно, модификации объекта не получилось, тем не менее замыкание получает доступ к приватным функциям и свойствам.<br><br><h4>Передача как параметры по умолчанию в методы доступа к данным</h4><br>Пример получения значения из массива GET. В случае его отсутствия значение будет получено путем вызова функции.<br><pre><code class="php">$name = Input::get('name', function() {return 'Fred';});
</code></pre><br><br><h4>Функции высшего порядка</h4><br>Здесь уже был пример создания валидатора. Приведу пример из фреймворка <a href="http://lithify.me/">lithium</a><br><br><pre><code class="php">/**
 * Writes the message to the configured cache adapter.
 *
 * @param string $type
 * @param string $message
 * @return closure Function returning boolean `true` on successful write, `false` otherwise.
 */
public function write($type, $message) {
	$config = $this->_config + $this->_classes;

	return function($self, $params) use ($config) {
		$params += array('timestamp' => strtotime('now'));
		$key = $config['key'];
		$key = is_callable($key) ? $key($params) : String::insert($key, $params);

		$cache = $config['cache'];
		return $cache::write($config['config'], $key, $params['message'], $config['expiry']);
	};
}
</code></pre><br>Метод возвращает замыкание, которое может быть использовано потом для записи сообщения в кеш.<br><br><h4>Передача в шаблоны</h4><br>Иногда в шаблон удобно передавать не просто данные, а, например, сконфигурированную функцию, которую можно вызвать из кода шаблона для получения каких либо значений.<br><br><pre><code class="php">//В контроллере
$layout->setLink = function($setId) use ($userLogin)
{
    return '/users/' . $userLogin . '/set/' . $setId;
};

//В шаблоне
<a href=<?=$this->setLink->__invoke($id);?>>Set name</a></code></pre><br>В данном случае в шаблоне генерировалось несколько ссылок на сущности пользователя и в адресах этих ссылок фигурировал его логин. <br><br><h4>Рекурсивное определение замыкания</h4><br>Напоследок о том, как можно задавать рекурсивные замыкания. Для этого нужно передавать в use ссылку на замыкание, и вызывать ее в коде. Не забывайте об условии прекращения рекурсии<br><br><pre><code class="php">$factorial = function( $n ) use ( &$factorial ) {
    if( $n == 1 ) return 1;
    return $factorial( $n - 1 ) * $n;
};

print $factorial( 5 );
</code></pre><br><br>Многие из примеров выглядят натянуто. Сколько лет жили без них — и ничего. Тем не менее иногда применение замыкания достаточно естественно и для PHP. Умелое использование этой возможности позволит сделать код более читаемым и увеличить эффективность работы программиста. Просто нужно немного подстроить свое мышление под новую парадигму и все станет на свои места. А вообще рекомендую сравнить, как используются такие вещи в других языках типа Python. Надеюсь, что кто-нибудь нашел для себя здесь что-то новое. И конечно, если кто-то знает еще какие-нибудь интересные применения замыканий, то очень жду ваши комментарии. Спасибо!</div>